# Frontend

Now that our backend is set up and documented, let's move on to creating the frontend of our real-time messaging application using React. We'll start by setting up the project structure and then implement user registration and authentication features.

## Step 1. Setting Up the Frontend with React

We start this step with going back one to our project main folder and then create a new folder that i like to call client for our frontend with create-react-app.

1. Change the directory out of the server folder with

```bash
cd ..
```

2. Create React client directory with

```bash
npx create-react-app client
```

3. Go into the newly created directory

```bash
cd client/
```

I do normally try to get things done in one go with multiple commands at once with `&&` in between my commands, but in this case it will interfere since creating React will take some time.

#### The Dependencies

- **date-fns:** Modern JavaScript date utility library.
- **react-firebase-hooks:** React hooks for Firebase integration.
- **react-router-dom:** Standard routing library for React.
- **jwt-decode:** Library for decoding JSON Web Tokens (JWTs).
- **Firebase:** Official Firebase JavaScript SDK.
- **axios:** Promise-based HTTP client for making requests to the backend.

I will explain more about each and everyone and how to implement and use them at a later stage in the guide.

You can install all of them in one go with the following command:

```bash
npm install date-fns react-firebase-hooks react-router-dom jwt-decode firebase axios
```

Your `package.json` will look like this after the installation of the dependencies:

```json
{
  "name": "client",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.7.2",
    "date-fns": "^3.6.0",
    "firebase": "^10.12.2",
    "jwt-decode": "^4.0.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-firebase-hooks": "^5.1.1",
    "react-router-dom": "^6.23.1",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": ["react-app", "react-app/jest"]
  },
  "browserslist": {
    "production": [">0.2%", "not dead", "not op_mini all"],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "proxy": "http://localhost:5001"
}
```

you might notice that there is an additional line in my code that you don't have. Its the `"proxy": "http://localhost:5001"` we add this to avoid `CORS` and `API requests` issues between your backend and front end. I will also reduce your code since you don't have to write out the url in your requests.
Instead of sending a request to `http://localhost:5001/api/some-endpoint` you send it to `/api/some-endpoint`.

Keep in mind that this proxy configuration only works in development mode and that you should handle proxying or CORS configurations on your backend server directly for production.

### Index and App

Before diving into creating our individual components, it's essential to refactor the main files that were generated by default when we created our React app. We need to adjust [`index.js`](/client/src/index.js) and redo [`App.js`](/client/src/App.js) almost completely. Here's why these changes are necessary and what we'll be doing in each file.

When you initialize a new React application using `create-react-app`, it generates some boilerplate code in the `index.js` and `App.js` files. While this code provides a good starting point, it doesn't cater to the specific needs of our application.

- **Integrate Context Providers:** We need to wrap our application with context providers such as AuthProvider to manage authentication state globally.
- **Set Up Routing:** We'll use React Router to manage navigation within our app. This requires setting up routes in `App.js`.
- **Add Global Styles and Dependencies:** We might need to include global styles or other dependencies that should be initialized at the entry point of our application.
- **Improve Project Structure:** By refactoring these files, we can ensure a clean and organized project structure, making it easier to manage and scale our application.

To integrate the Context Provider, we first need to create one, which we will cover later in this guide. For now, we only need to import `{ BrowserRouter } from "react-router-dom"` into the `index.js` file and change `<React.StrictMode>` to `<BrowserRouter>`.

This setup allows us to use React Router for managing our application's navigation. Using `BrowserRouter` enables client-side routing, providing a more seamless and dynamic user experience without full page reloads.

As for `App.js`, you can remove the first line with the `logo` and the entire `return` statement, as we don't need any of this. Instead, we will be using `Routes`. So, we need to import `React from "react"` and `{ Routes, Route } from "react-router-dom"`.

- **Routes:** A component from `react-router-dom` that manages a collection of `Route` components and renders the first one that matches the current URL.
- **Route:** A component from `react-router-dom` that defines a mapping between a URL path and a corresponding component to render when the path is matched.

Let's insert `<> </>` into the `return` statement, which will act as a placeholder for now. We will add the Context Provider here later after creating and importing the component. Inside this placeholder, we will set up `Routes` and a `Route`. We will keep the elements empty for now and add the components after we create them. Just add the `Routes` and `Route` components between the arrows we just inserted into the return. The `"/"` route will act as our home page, and `"*"` is a catch-all route that will handle mistyped URLs or those that are not available.

```javascript
<>
  <Routes>
    <Route path="/" element={< />} />
    <Route path="*" element={< />} />
  </Routes>
</>
```

We will come back here after the next step.

## Step 2. Registration and Sign-in

In a typical application or website, you would have various components such as a landing page, registration, sign-in, and maybe a profile page for the user, along with other components specific to your project. To keep things simple for this guide, I will set up just one landing page with a signup or sign-in component. With a successful login, you'll be redirected directly to the messaging app. We'll display all registered users in a list next to the messaging window for simplicity.

#### Creating Component Files

Let's create all the files we'll work on first: `Login.jsx` for all sign-in related components, `Signup.jsx` for all signup related components, `firebaseConfig.jsx` for Firebase configuration.

Move into the `src/` directory and create a directory for all our components:

```bash
cd src/ && mkdir components
```

Then create the files:

```bash
cd components/ && touch Login.jsx Signup.jsx firebaseConfig.jsx
```

#### Understanding JSX

You might be wondering why we're using .jsx file extensions. JSX stands for JavaScript XML. It's a syntax extension for JavaScript that allows you to write HTML directly within JavaScript. This is particularly useful in React, as it allows you to describe the UI in a more intuitive and readable way.

Some pros of using .jsx are:

- **Readability:** Writing HTML-like syntax directly within your JavaScript code makes it easier to visualize the structure of your UI components.
- **Component-Based:** Enhances the development of component-based architectures by making the code more modular and reusable.
- **Integration:** JSX integrates seamlessly with the React library, enabling a more straightforward development workflow.

One of the cons of using .jsx is:

**Build Process:** Requires a build step (using tools like Babel) to transform JSX into regular JavaScript, adding complexity to the setup.

#### Installing Babel

To use JSX in your React project, we need to install Babel. Babel is a JavaScript compiler that allows you to use next-generation JavaScript, including JSX, by transforming it into a format that browsers can understand.

Change the directory back to `client/` and install Babel:

```bash
cd ../../ && npm install --save-dev @babel/core @babel/preset-env @babel/preset-react babel-loader
```

### 1. Firebase

We work on `firebaseConfig.jsx` to set up Google Login.

#### Creating Files and Directory

Before we continue, let's create a separate directory for this file and move `firebaseConfig.jsx` there for better structure. Inside the `/client` directory, use the following command to create the `config` directory:

```bash
mkdir src/components/config
```

You can now also create a `.env` file for the Firebase info to keep the information secure.

```bash
touch .env
```

#### .ENV

We already created our project earlier on Firebase and got the sensitive information for our backend, now we go back to the `Firebase Console` choose our project and then click on `Authentication` in the left menu. Go to the `Sign-in method` tab, find `Google` in the list of sign-in providers and click `Enable`. Now just follow the instructions to set up the Google OAuth consent screen. Make sure to provide the required information and save your changes.

Now on the left find the gear icon next to your `Project Overview` and select `Project settings` we have been here before if you remember well. In the `General` tab scroll down to `SDK setup and configuration` and find `const firebaseConfig`, this i the info that we need for our firebase configuration.

The `.env` file content should look like this with you replacing the `YOUR_...` with the actual Key, Domain, Id and so on.

```env
REACT_APP_FIREBASE_API_KEY=YOUR_API_KEY
REACT_APP_FIREBASE_AUTH_DOMAIN=YOUR_AUTH_DOMAIN
REACT_APP_FIREBASE_PROJECT_ID=YOUR_PROJECT_ID
REACT_APP_FIREBASE_STORAGE_BUCKET=YOUR_STORAGE_BUCKET
REACT_APP_FIREBASE_MESSAGING_SENDER_ID=YOUR_MESSAGING_SENDER_ID
REACT_APP_FIREBASE_APP_ID=YOUR_APP_ID
```

#### Firebase Component

In your `src/components/config/firebaseConfig.jsx` file, we'll initialize Firebase and set up the services we need. Here's a breakdown of what we're doing:

#### Dependencies

```javascript
import { initializeApp } from "firebase/app";
import { getAuth } from "firebase/auth";
import { getFirestore } from "firebase/firestore";
```

- **initializeApp from "firebase/app":** This function initializes the Firebase app with our configuration.
- **getAuth from "firebase/auth":** This function initializes Firebase Authentication, which we'll use for user sign-in.
- **getFirestore from "firebase/firestore":** This function initializes Firestore, Firebase's NoSQL cloud database.

#### Configuration

Next we add the variable for the configuration like we seen on the Firebase Console when we copied the information for our `.env` file. access the secured data from the file with `process.env`.

```javascript
const firebaseConfig = {
  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,
  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,
  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.REACT_APP_FIREBASE_APP_ID,
  measurementId: process.env.REACT_APP_FIREBASE_MEASUREMENT_ID,
};
```

Note: The `measurementId` is optional. It's used for Firebase Analytics, which we're not setting up right now. You can include it for future use or omit it if you don't plan to use Analytics.

#### Initialize Service

Follow with initializing Firebase and Services:

```javascript
const firebaseApp = initializeApp(firebaseConfig);
const firebaseAuth = getAuth(firebaseApp);
const fireDB = getFirestore(firebaseApp);
```

Even though we're focusing on Authentication now, initializing Firestore (`fireDB`) allows us to easily add database functionality later without changing this configuration file.

#### Export

Export both the Authentication and Firestore instances. This allows us to import and use these services in other parts of our application as needed.

```javascript
export { firebaseAuth, fireDB };
```

**Firebase Authentication (firebaseAuth):** This service will handle user sign-up, sign-in, and sign-out operations. You'll use this in components that deal with user authentication, like login forms or user profile pages.

**Firestore (fireDB):** While we're not using it immediately, Firestore is Firebase's flexible, scalable NoSQL cloud database. You'll use this for storing and syncing data for your app in real-time. It can be used for features like storing user data, chat messages, or any other data your app needs to persist (What we will be using for our chat messages).

This setup provides a solid foundation for adding Firebase functionality to your React application. You can check the [file firebaseConfig.jsx](/client/src/components/config/firebaseConfig.jsx) to see the complete code and find detailed comments explaining each line of the code.

### 2. Signup

Now we work on the Signup

#### Dependencies

First, we import all necessary dependencies:

```javascript
import React, { useState } from "react";
import axios from "axios";
import { useNavigate } from "react-router-dom";
```

- **React and useState:** For building the component and managing state.
- **axios:** For making HTTP requests to our API.
- **useNavigate:** A hook from react-router-dom for programmatic navigation.

(Normally, we would use **createUserWithEmailAndPassword from "firebase/auth"** to create a user in Firebase. However, since we have our own API backend set up in the `userController` using the Firebase Admin SDK, we won't be needing this here.)

#### SignupForm Component

We define our component, accepting `setSelectedTab` as a prop:

```javascript
const SignupForm = ({ setSelectedTab }) => {
  // Component code here
};
```

#### State Variables

We use `useState` to manage our component's state:

**useState** is a React hook that allows functional components to manage local state. It is used for holding and updating state values within a component without needing to use class components or directly manipulating the DOM (Document Object Model).

We declare the following variables. You can customize their names as needed and, of course, adjust the application to work with fewer variables:

```javascript
const [email, setEmail] = useState("");
const [password, setPassword] = useState("");
const [confirmPassword, setConfirmPassword] = useState("");
const [passwordError, setPasswordError] = useState("");
const [errorMessage, setErrorMessage] = useState("");
const [successMessage, setSuccessMessage] = useState("");
```

- **setEmail, setPassword, setConfirmPassword, etc.:** are functions provided by React to update the corresponding state variables.
- **email, password, confirmPassword, etc.:** When called, these functions trigger a re-render of the component with the updated state value.
- **passwordError, errorMessage, successMessage:** These are additional state variables used to manage specific states within your component, such as displaying validation errors (**passwordError**) or success messages (**successMessage**).

We create the `navigate` variable using the imported `useNavigate` hook, which is used for navigating to different routes.

```javascript
const navigate = useNavigate();
```

#### Implement Signup Functionality

We create an asynchronous `handleSignup` function to manage the signup process:

```javascript
const handleSignup = async (e) => {
  // Component code here
};
```

An `asynchronous` function allows the use of `await` inside to pause execution until promises are settled, typically used with API calls or other async operations.

1. Prevent the default form submission behavior. This prevents the default behavior of an event, such as form submission or link navigation, ensuring that the event doesn't trigger its default action. Next clear all error messages in case the user attempts to sign up multiple times due to errors. Ensure that the password matches the confirmed password with an `if` conditional statement before allowing the user to continue.

```javascript
e.preventDefault();
```

2. Clear error message for returning users.

```javascript
setPasswordError("");
setSuccessMessage("");
setErrorMessage("");
```

3. Check passwords match before proceeding.

```javascript
if (password !== confirmPassword) {
  setPasswordError("Passwords don't match");
  setConfirmPassword("");
  return;
}
```

4. Create a new user object with email and password.
5. Send a POST request to /api/users/register with the new user's data.
6. If the registration is successful and the response contains user data with firebaseId:
7. Clear the email, password, and confirmPassword fields.
8. Set a success message.
9. If the response does not contain the expected user data, throw an error indicating registration failure.

```javascript
 try {
    const newUser = { email, password };
    const response = await axios.post("/api/users/register", newUser);

    if (response.data && response.data.user && response.data.user.firebaseId) {
      setEmail("");
      setPassword("");
      setConfirmPassword("");
      setSuccessMessage(response.data.message);
    } else {
      throw new Error("User registration failed: Missing user data");
    }
  }
```

10. If the error response status is 400, set an error message indicating the email already exists and clear the email field.
11. For other errors, log the error, set a general registration failure message, and clear the email, password, and confirmPassword fields.

```javascript
catch (error) {
    if (error.response && error.response.status === 400) {
      setErrorMessage("Email already exists!");
      setEmail("");
    } else {
      console.error("Signup failed:", error);
      setErrorMessage("Registration failed. Please try again.");
      setEmail("");
      setPassword("");
      setConfirmPassword("");
    }
  }
```

You may have noticed the frequent use of `set...` functions. This ensures a smoother user experience: if the password doesn't match, the password field is cleared for another attempt. Similarly, if an email already exists in the system, the email field is cleared for a retry. Before providing a new response message, any prior messages are cleared to avoid confusion.

#### Render UI

Now we work on the `return` of this component. Return (in a React component) renders content in a React component, returning JSX (JavaScript XML) that represents the UI to be displayed based on the component's current state or props.

Since this is the Signup, we need to gather the email and password from the user, along with a third input to confirm the password. Here's how we'll structure it:

1. Start with a heading to introduce the signup process.

```html
<h2>Create a New Account</h2>
```

2. Use a form to collect user inputs like email, password, and confirm password. Also, provide labels for clarity on each input field.

```javascript
<form className="signup-form" onSubmit={handleSignup}>
  <label htmlFor="email">Email</label>
  <input
    type="email"
    id="email"
    value={email}
    onChange={(e) => setEmail(e.target.value)}
    required
  />
  <label htmlFor="password">Password</label>
  <input
    type="password"
    id="password"
    value={password}
    onChange={(e) => setPassword(e.target.value)}
    required
  />
  <label htmlFor="confirmPassword">Confirm Password</label>
  <input
    type="password"
    id="confirmPassword"
    value={confirmPassword}
    onChange={(e) => setConfirmPassword(e.target.value)}
    required
  />
  // space for error messages and submit button
</form>
```

- **onSubmit:** This attribute specifies the function to be called when the form is submitted, in our case the `handleSignup` function.
- **htmlFor:** This attribute in React is the equivalent of the `for` attribute in standard HTML. It is used to associate a <`label`> element with an <`input`> element.
- **type:** Specifies the type of input element, such as "text", "email", "password", etc.
- **id:** Provides a unique identifier for the input element, useful for associating labels with inputs.
- **value:** Sets the current value of the input element.
- **onChange:** Is the event handler that updates the state when the value of the input element changes.

**Guide Tip:**
Start making use of the **className** attribute! This sets the CSS class of an HTML element, enabling you to apply specific styles defined in your CSS files to that element. We will do some minor styling later at the end of this guide.

3. Implement a button for submitting the signup information.

```javascript
<button
  type="submit"
  className="signup-form-btn"
  disabled={!email || !password || !confirmPassword}
>
  Continue
</button>
```

- **disabled:** The attribute disables the button (makes it unclickable) if any of the `email`, `password`, or `confirmPassword` state variables are empty.

4. Next, add conditional rendering to the components by using a ternary operator. If `!successMessage` (indicating no success message), we'll render the signup form. If there's a positive `successMessage`, we'll display a success message instead of the input fields.

```javascript
<div className="credentials-form">
  {!successMessage ? (
    <>
      <h2></h2>
      <form></form>
    </>
  ) : (
    <div className="signup-success">
      <h2>{successMessage}!</h2>
      <p className="signup-email-message">
        An email has been sent to your email address for confirmation.
      </p>
      <button
        onClick={() => {
          setSuccessMessage("");
          setSelectedTab("Login");
          navigate("/");
        }}
        className="signup-email-message-btn"
      >
        Close
      </button>
    </div>
  )}
</div>
```

I added a component to display a message ("An email has been sent...") in case of success and add a close button to exit the finished process. The emailing part in the code is just a placeholder for now, and you would need to set up the service to email the user in case of successful registration yourself with some email service provider like SendGrid or AWS SES.

5. Display error messages conditionally. If `errorMessage` or `passwordError` is set, render the message below the last input and above the "Continue" button.

```html
{passwordError &&
<p className="signup-error">{passwordError}</p>
}{" "} {errorMessage &&
<p className="signup-error">{errorMessage}</p>
}
```

#### Export Component

Export the component as the default export to make it available for use in other parts of our application.

```javascript
export default SignupForm;
```

The [file Signup.jsx](/client/src/components/Signup.jsx) has detailed inline comments to explain everything further.

### 3. Login

After completing the Signup, we move straight to the Login, which handles user authentication for existing users.

We work the `Login.jsx` file in /client/src/components/

#### Import Dependencies

First, import the necessary dependencies:

- **React and useState**
- **axios**
- **useNavigate**
- **Firebase Authentication Methods:** These are functions from Firebase Authentication (`signInWithEmailAndPassword`, `signInWithPopup`, `GoogleAuthProvider`) used for handling user login and authentication.
- The previously created **firebaseAuth** component.

#### Define State Variables

Define state variables to manage user inputs and authentication states:

- **[email, setEmail]:** State to store the user's email input.
- **[password, setPassword]:** State to store the user's password input.
- **[wrongCredential, setWrongCredential]:** State to manage error messages for incorrect credentials.
- **[authError, setAuthError]:** State to manage error messages for authentication failures.

Create the `navigate` variable using the imported `useNavigate` hook, which is used for navigating to different routes.

```javascript
const navigate = useNavigate();
```

#### Implement Login Functionality

The `handleLogin` function is an asynchronous function that handles the submission of the login form:

```javascript
const handleLogin = async (e) => {
  // Component code here
};
```

1. Prevent the default form submission behavior.
2. Authenticate the user with `email` and `password` using `signInWithEmailAndPassword` from Firebase.
3. Obtain a Firebase Authentication token (`fcmToken`) for the authenticated user.
4. Log the current `displayName` from Firebase Auth (for debugging purposes).
5. Send a POST request to `/api/users/login` with the user's email, password, fcmToken, displayName, and uid.
6. Store the received token in local storage.
7. Navigate to the home page ("/") upon successful authentication.
8. If there are any errors, set `wrongCredential` to display an error message and clear the email and password fields.

```javascript
e.preventDefault();
try {
  const userCredential = await signInWithEmailAndPassword(
    firebaseAuth,
    email,
    password
  );
  const user = userCredential.user;

  const fcmToken = await user.getIdToken();

  const response = await axios.post("http://localhost:5001/api/users/login", {
    email: user.email,
    password,
    fcmToken,
  });

  localStorage.setItem("userToken", response.data.token);
  navigate("/");
} catch (error) {
  setWrongCredential("Incorrect email or password! Please try again.");
  setEmail("");
  setPassword("");
}
```

#### Implement Google Login Functionality

The `handleGoogleLogin` function handles authentication using Google OAuth:

`Google OAuth` (Open Authorization) is a secure authentication protocol used by Google services to allow third-party applications to access user data without requiring the user to share their login credentials. It enables users to grant websites or applications limited access to their Google account information, such as their email address or profile data, without revealing their password.

```javascript
const handleGoogleLogin = async () => {
  // Component code here
};
```

1. Create a new instance of `GoogleAuthProvider`.
2. Initiate a popup-based authentication flow using `signInWithPopup`.
3. Retrieve the user's Firebase user object and get an `fcmToken`.
4. Log the current `displayName` from Google Auth (for debugging purposes).
5. Send a POST request to `/api/users/firelogin` with the user's email, uid, fcmToken, and displayName.
6. Store the received token in local storage.
7. Navigate to the home page.
8. If there's an error, set `authError` to display an error message.

```javascript
try {
  const provider = new GoogleAuthProvider();
  const result = await signInWithPopup(firebaseAuth, provider);
  const user = result.user;

  const fcmToken = await user.getIdToken();

  console.log("Current displayName from Google Auth:", user.displayName);

  const response = await axios.post(
    "http://localhost:5001/api/users/firelogin",
    {
      email: user.email,
      uid: user.uid,
      fcmToken,
      displayName: user.displayName,
    }
  );

  localStorage.setItem("userToken", response.data.token);
  navigate("/");
} catch (error) {
  setAuthError("Failed to login with Google.");
}
```

#### Render UI

The `return` component renders a form for email and password inputs, along with buttons for login and Google login:

At this point, you should be familiar with HTML headings, forms, user inputs, and buttons from the Signup component, so I will not go into too much detail here. Instead, I'll guide you on what you need to do.

1. Display a heading prompting users to sign in.
2. Provide input fields for email and password with corresponding labels.
3. Render conditional error messages (`wrongCredential` and `authError`) if authentication fails.
4. Implement a button for submitting the form.
5. Implement a button for Google login.

```javascript
return (
  <div className="form-container">
    <h2>Sign in to your account</h2>
    <form onSubmit={handleLogin}>
      <label>Email</label>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        required
      />
      <label>Password</label>
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        required
      />
      {wrongCredential && <p className="error">{wrongCredential}</p>}{" "}
      {authError && <p className="error">{authError}</p>}{" "}
      <button type="submit">Continue</button>{" "}
    </form>
    <button onClick={handleGoogleLogin} className="google-login-btn">
      Continue with Google
    </button>
  </div>
);
```

#### Export Component

Finally, export the `LoginForm` component as the default export to make it available for use in other parts of our application.

```javascript
export default LoginForm;
```

The [file Login.jsx](/client/src/components/Login.jsx) has detailed inline comments to explain everything further.

## Step 3. Context and Encryption

I will create an AuthContext component that will track our authentication status across any page or level of the app, NotificationContext to create message notifications and implement message encryption.

#### Creating Component Files

Let's create all the files we'll work on first: `Encryption.jsx`, `AuthContext.jsx` and `NotificationContext.jsx`.

Move into the `/client/src/components` directory and create a directory for our context and encryption:

```bash
mkdir context utils
```

Then create the files:

```bash
touch utils/Encryption.jsx context/AuthContext.jsx context/NotificationContext.jsx
```

### 1. Before We Start, Let's Talk Security

Nowadays, a messaging app is unacceptable without proper message privacy. That means before we start, we will have to think about message encryption. Since this is the first time I am building this app with privacy in mind and this wasn't needed in my previous project, I need to find the right solution to handle the encryption of the messages. I have two contenders in mind and I have already decided on the one that is easier to implement (for now!). I will introduce both and state their pros and cons.

**Signal Protocol vs. Web Crypto API:**

1. **Signal Protocol**

   - **Pros:**
     - Widely used in popular messaging apps like WhatsApp and Signal.
     - Open-source! Allows for public scrutiny and auditing.
   - **Cons:**
     - Complex and requires a deep understanding of cryptographic principles.
     - Requires an additional library: typically implemented using `libsignal-protocol-javascript`.

2. **Web Crypto API**
   - **Pros:**
     - Built into modern browsers, so there is no need for external libraries.
     - Simpler and more straightforward for basic encryption needs.
   - **Cons:**
     - Not specifically designed for secure messaging protocols.
     - Limited to browser environments and may not be suitable for all types of applications.

**Major Differences:**

- **Specialization:** Signal Protocol is specifically designed for secure messaging, while Web Crypto API is a general-purpose cryptographic API.
- **Ecosystem:** Signal Protocol has a dedicated library and is widely used in messaging apps. Web Crypto API is a web standard supported by modern browsers.

For the initial implementation of this messaging app, the Web Crypto API is chosen due to its simplicity and built-in browser support. However, I'll be keeping Signal Protocol as a potential upgrade path for a future version of this app and will dedicate my time to write another guide about the change from Web Crypto to the Signal Protocol.

### 2. Message Encryption

Let's implement the chosen message encryption standard Web Crypto API as our message privacy feature. We work on the Encryption file.

#### Key Generation and Management

We'll start by implementing functions to generate, export, and import encryption keys using the `window.crypto.subtle` Web Crypto API interface. This interface provides cryptographic operations such as hashing, encryption, decryption, and key generation in a secure and performant manner.

1. This function generates an RSA key pair using RSA-OAEP with a 2048-bit key length and SHA-256 hash.

```javascript
const generateKeyPair = async () => {
  const keyPair = await window.crypto.subtle.generateKey(
    {
      name: "RSA-OAEP",
      modulusLength: 2048,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: "SHA-256",
    },
    true,
    ["encrypt", "decrypt"]
  );
  return keyPair;
};
```

- **keyPair:** Stores the pair of RSA keys (public and private) generated for encryption and decryption.
- **RSA-OAEP:** [Optimal Asymmetric Encryption Padding](https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding) is an encryption scheme that combines [RSA](<https://en.wikipedia.org/wiki/RSA_(cryptosystem)>) encryption with padding to ensure secure and reliable encryption of messages
- **Uint8Array([1, 0, 1]):** Specifies the public exponent. The public exponent is a part of the RSA algorithm and is typically set to [65537](https://en.wikipedia.org/wiki/65,537). This value is chosen because it is a prime number that balances security and computational efficiency.
- **SHA-256:** [Secure Hash Algorithm](https://en.wikipedia.org/wiki/Secure_Hash_Algorithms) Commonly used for data integrity and security in various applications.

2. These functions convert keys to storable formats: public keys to Base64 encoded strings and private keys to JSON Web Key (JWK) format.

```javascript
const exportPublicKey = async (publicKey) => {
  const exported = await window.crypto.subtle.exportKey("spki", publicKey);
  return btoa(String.fromCharCode.apply(null, new Uint8Array(exported)));
};

const exportPrivateKey = async (privateKey) => {
  const exported = await window.crypto.subtle.exportKey("jwk", privateKey);
  return JSON.stringify(exported);
};
```

- **publicKey:** Holds the public key used for encrypting messages.
- **privateKey:** Stores the private key used for decrypting messages.
- **exported:** Holds the exported key data in a raw format before encoding.
- **btoa():** Converts the binary key data to a [Base64](https://en.wikipedia.org/wiki/Base64) encoded string.
- **fromCharCode.apply():** JavaScript method used to convert an array of Unicode values (or an array-like object containing Unicode values) into a string.
- **spki:** Stands for "Subject Public Key Info", a standard format for public keys.
  Not to be confused with "Simple Public Key Infrastructure".
  Differences:
  - **SPKI (Simple Public Key Infrastructure):** A simplified framework for associating public keys with authorizations and attributes, aiming to reduce the complexity of traditional PKI.
  - **SPKI (Subject Public Key Info):** A specific field within an X.509 certificate that contains the public key and associated algorithm information.

3. These functions convert stored key formats back into CryptoKey objects for encryption and decryption.

```javascript
const importPublicKey = async (publicKeyString) => {
  try {
    const binaryDerString = atob(publicKeyString);
    const binaryDer = new Uint8Array(binaryDerString.length);
    for (let i = 0; i < binaryDerString.length; i++) {
      binaryDer[i] = binaryDerString.charCodeAt(i);
    }
    return await window.crypto.subtle.importKey(
      "spki",
      binaryDer,
      {
        name: "RSA-OAEP",
        hash: "SHA-256",
      },
      true,
      ["encrypt"]
    );
  } catch (error) {
    console.error("Error importing public key:", error);
    throw new Error("Invalid public key format");
  }
};

const importPrivateKey = async (privateKeyString) => {
  try {
    const jwk = JSON.parse(privateKeyString);
    return await window.crypto.subtle.importKey(
      "jwk",
      jwk,
      {
        name: "RSA-OAEP",
        hash: "SHA-256",
      },
      true,
      ["decrypt"]
    );
  } catch (error) {
    console.error("Error importing private key:", error);
    throw new Error("Invalid private key format");
  }
};
```

- **publicKeyString:** Contains the Base64 encoded string representation of the public key.
- **privateKeyString:** Stores the JSON Web Key (JWK) string representation of the private key.
- **binaryDerString:** Holds the decoded Base64 string representation of the public key before converting it to a binary format.
- **binaryDer:** Contains the binary representation of the DER-encoded public key.
- **atob():** This method decodes a string that has been encoded by the `btoa()` method.
- **charCodeAt(i):** JavaScript string method that returns the Unicode code point of the character at the specified index `i` in the string, useful for converting characters to their numerical representation.
- **for loop:** General explanation of iterating over characters in a string using a `for` loop:
  1. Begin the loop with `i` initialized to 0.
  2. Continue iterating as long as `i` is less than the string's length.
  3. Within each iteration, use `charCodeAt(i)` to retrieve the Unicode value (numerical representation) of the character at position `i`.
  4. Store this numerical value in an array or variable for further use.
  5. Increment `i` by 1 to move to the next character in the string, and repeat steps 3 to 5 until all characters have been processed.

6. This function generates a random AES key for use in symmetric encryption.

```javascript
const generateAESKey = async () => {
  return await window.crypto.subtle.generateKey(
    {
      name: "AES-GCM",
      length: 256,
    },
    true,
    ["encrypt", "decrypt"]
  );
};
```

- **encrypt:** Specifies that the generated AES key can be used for encryption operations.
- **decrypt:** Specifies that the generated AES key can be used for decryption operations.

#### Message Encryption and Decryption

Next, we'll implement functions to encrypt and decrypt messages:

1. This function encrypts a single message for multiple recipients using a combination of AES-GCM and RSA-OAEP encryption.

```javascript
const encryptMessageForMultipleRecipients = async (
  message,
  recipientPublicKeys
) => {
  const aesKey = await generateAESKey();

  const encoder = new TextEncoder();
  const data = encoder.encode(message);
  const iv = window.crypto.getRandomValues(new Uint8Array(12));
  const encryptedContent = await window.crypto.subtle.encrypt(
    {
      name: "AES-GCM",
      iv: iv,
    },
    aesKey,
    data
  );

  const exportedAesKey = await window.crypto.subtle.exportKey("raw", aesKey);
  const encryptedAesKeys = await Promise.all(
    recipientPublicKeys.map(async (publicKey) => {
      const encryptedKey = await window.crypto.subtle.encrypt(
        {
          name: "RSA-OAEP",
        },
        publicKey,
        exportedAesKey
      );
      return btoa(
        String.fromCharCode.apply(null, new Uint8Array(encryptedKey))
      );
    })
  );

  const encryptedPackage = {
    encryptedContent: btoa(
      String.fromCharCode.apply(null, new Uint8Array(encryptedContent))
    ),
    encryptedAesKeys: encryptedAesKeys,
    iv: btoa(String.fromCharCode.apply(null, iv)),
  };
  return JSON.stringify(encryptedPackage);
};
```

- **aesKey:** A symmetric encryption key used in the Advanced Encryption Standard algorithm.
- **AES-GCM:** (Advanced Encryption Standard in Galois/Counter Mode) is a mode of operation for symmetric key encryption using the [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard) algorithm.
- **TextEncoder():** Built-in JavaScript object that converts a string into a Uint8Array of encoded bytes, typically used for encoding text in UTF-8 format.

2. This function decrypts an encrypted message using the recipient's private key.

```javascript
const decryptMessage = async (privateKey, encryptedMessage) => {
  try {
    let encryptedPackage;
    try {
      encryptedPackage = JSON.parse(encryptedMessage);
    } catch (parseError) {
      console.error("Failed to parse encrypted message:", parseError);
      throw new Error("Invalid encrypted message format: not a valid JSON");
    }

    if (
      !encryptedPackage.encryptedContent ||
      !encryptedPackage.encryptedAesKeys ||
      !encryptedPackage.iv
    ) {
      throw new Error("Invalid encrypted package structure");
    }

    let decryptedAesKey;
    for (const encryptedAesKey of encryptedPackage.encryptedAesKeys) {
      try {
        const encryptedKeyData = new Uint8Array(
          atob(encryptedAesKey)
            .split("")
            .map((char) => char.charCodeAt(0))
        );
        decryptedAesKey = await window.crypto.subtle.decrypt(
          { name: "RSA-OAEP" },
          privateKey,
          encryptedKeyData
        );
        break;
      } catch (error) {
        console.error("Failed to decrypt AES key, trying next one");
      }
    }

    if (!decryptedAesKey) {
      throw new Error("Failed to decrypt any AES key");
    }

    const aesKey = await window.crypto.subtle.importKey(
      "raw",
      decryptedAesKey,
      { name: "AES-GCM" },
      false,
      ["decrypt"]
    );

    const encryptedContent = new Uint8Array(
      atob(encryptedPackage.encryptedContent)
        .split("")
        .map((char) => char.charCodeAt(0))
    );
    const iv = new Uint8Array(
      atob(encryptedPackage.iv)
        .split("")
        .map((char) => char.charCodeAt(0))
    );

    const decryptedContent = await window.crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv: iv,
      },
      aesKey,
      encryptedContent
    );

    const decoder = new TextDecoder();
    const decodedMessage = decoder.decode(decryptedContent);
    return decodedMessage;
  } catch (error) {
    console.error("Detailed error in decryptMessage:", error);
    throw new Error("Failed to decrypt message: " + error.message);
  }
};
```

- **encoder and decoder:** Utilized for encoding and decoding strings to and from Uint8Array format.

#### Private Key Security

To enhance security, I added functions to encrypt and decrypt the user's private key with a password:

1. This function encrypts a private key string using AES-GCM encryption with a password-derived key.

```javascript
const encryptPrivateKey = async (privateKeyString, password) => {
  const encoder = new TextEncoder();
  const data = encoder.encode(privateKeyString);
  const salt = window.crypto.getRandomValues(new Uint8Array(16));
  const key = await window.crypto.subtle.importKey(
    "raw",
    encoder.encode(password),
    { name: "PBKDF2" },
    false,
    ["deriveKey"]
  );
  const derivedKey = await window.crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: salt,
      iterations: 100000,
      hash: "SHA-256",
    },
    key,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt"]
  );
  const iv = window.crypto.getRandomValues(new Uint8Array(12));
  const encrypted = await window.crypto.subtle.encrypt(
    {
      name: "AES-GCM",
      iv: iv,
    },
    derivedKey,
    data
  );
  const encryptedData = new Uint8Array(encrypted);
  const result = new Uint8Array(salt.length + iv.length + encryptedData.length);
  result.set(salt, 0);
  result.set(iv, salt.length);
  result.set(encryptedData, salt.length + iv.length);
  return btoa(String.fromCharCode.apply(null, result));
};
```

- **data:** Stores the encoded message or key data as a Uint8Array.
- **encrypted:** Holds the encrypted data after performing an encryption operation.
- **salt:** Stores the random salt used in the key derivation function (KDF) for encrypting private keys.
- **iv:** Holds the initialization vector used in the AES-GCM encryption algorithm.
- **result:** Combines the salt, IV, and encrypted data into a single Uint8Array for storage or transmission.
- **PBKDF2:** ([Password-Based Key Derivation Function](https://en.wikipedia.org/wiki/PBKDF2)) is designed to strengthen passwords against brute-force attacks by applying a computationally intensive hashing process with a salt (random value) and multiple iterations. It derives a secure encryption key from the password, ensuring that the resulting key is suitable for encryption purposes.
- **deriveKey:** Function used in cryptography to derive a new cryptographic key from an existing key and other parameters, such as a salt or password.

2. This function decrypts an encrypted private key using a password.

```javascript
const decryptPrivateKey = async (encryptedPrivateKey, password) => {
  const encoder = new TextEncoder();
  const encryptedData = new Uint8Array(
    atob(encryptedPrivateKey)
      .split("")
      .map((char) => char.charCodeAt(0))
  );
  const salt = encryptedData.slice(0, 16);
  const iv = encryptedData.slice(16, 28);
  const data = encryptedData.slice(28);
  const key = await window.crypto.subtle.importKey(
    "raw",
    encoder.encode(password),
    { name: "PBKDF2" },
    false,
    ["deriveKey"]
  );
  const derivedKey = await window.crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: salt,
      iterations: 100000,
      hash: "SHA-256",
    },
    key,
    { name: "AES-GCM", length: 256 },
    false,
    ["decrypt"]
  );
  const decrypted = await window.crypto.subtle.decrypt(
    {
      name: "AES-GCM",
      iv: iv,
    },
    derivedKey,
    data
  );
  const decoder = new TextDecoder();
  return decoder.decode(decrypted);
};
```

- **decrypted:** Contains the decrypted data after performing a decryption operation.
- The methods **(split, map, slice)** are used here in sequence to correctly parse and extract the components (salt, IV, encrypted data) from the Base64-encoded string (`encryptedPrivateKey`).
  - **split(""):** This method splits the decoded Base64 string into an array of characters. Each character in the string represents a byte of the encoded data.
  - **map((char) => char.charCodeAt(0)):** This method iterates over each character (byte) in the array and converts it back into its original numeric byte representation using `char.charCodeAt(0)`. This step is necessary because `atob` returns characters, and `charCodeAt(0)` converts each character to its Unicode code point.
  - **slice:** These methods are used to extract specific portions of the array (`encryptedData`) that represent different parts of the encrypted data.

#### User Key Management

I added functions to manage user keys in Firebase:

1. This function generates a new RSA key pair for a user, exports the keys to strings, and stores them in Firestore.

```javascript
const setupUserKeys = async (uid) => {
  if (!uid) {
    throw new Error("User ID is required to set up keys");
  }

  try {
    const keyPair = await generateKeyPair();
    const publicKeyString = await exportPublicKey(keyPair.publicKey);
    const privateKeyString = await exportPrivateKey(keyPair.privateKey);

    const userDocRef = doc(fireDB, "users", uid);
    await setDoc(
      userDocRef,
      {
        publicKey: publicKeyString,
        privateKey: privateKeyString,
      },
      { merge: true }
    );

    return { publicKey: keyPair.publicKey, privateKey: keyPair.privateKey };
  } catch (error) {
    console.error("Error setting up user keys:", error);
    throw error;
  }
};
```

2. This function retrieves RSA public and private keys associated with a specific user ID from Firestore.

```javascript
const getUserKeys = async (userId) => {
  const userDocRef = doc(fireDB, "users", userId);
  const userDoc = await getDoc(userDocRef);

  if (
    userDoc.exists() &&
    userDoc.data().publicKey &&
    userDoc.data().privateKey
  ) {
    try {
      const publicKey = await importPublicKey(userDoc.data().publicKey);
      const privateKey = await importPrivateKey(userDoc.data().privateKey);
      return { publicKey, privateKey };
    } catch (error) {
      console.error("Error importing keys:", error);
      throw new Error("Failed to import user keys");
    }
  } else {
    throw new Error("User keys not found");
  }
};
```

3. This function initializes and stores encryption keys for a user in Firestore and localStorage.

```javascript
const initializeKeys = async (uid, publicKeyString, privateKeyString) => {
  if (!uid) {
    throw new Error("User ID is required to initialize keys");
  }

  try {
    const userDocRef = doc(fireDB, "users", uid);
    await setDoc(
      userDocRef,
      {
        publicKey: publicKeyString,
        privateKey: privateKeyString,
      },
      { merge: true }
    );

    localStorage.setItem(`publicKey_${uid}`, publicKeyString);

    console.log("Keys initialized successfully");
    return { publicKey: publicKeyString, privateKey: privateKeyString };
  } catch (error) {
    console.error("Error initializing keys:", error);
    throw error;
  }
};
```

#### Export

Export all functions using named exports to complete this component.

```javascript
export {
  generateKeyPair,
  exportPublicKey,
  exportPrivateKey,
  importPublicKey,
  importPrivateKey,
  generateAESKey,
  encryptMessageForMultipleRecipients,
  decryptMessage,
  encryptPrivateKey,
  decryptPrivateKey,
  setupUserKeys,
  getUserKeys,
  initializeKeys,
};
```

- **generateKeyPair**: Required to generate a pair of keys for encryption and decryption operations. These keys are fundamental for secure communication and data protection.
- **exportPublicKey**: Essential for exporting an public key to a format that can be shared securely.
- **exportPrivateKey**: Needed to export an private key in a secure format (JWK).
- **importPublicKey**: Vital for importing an public key from a Base64-encoded string.
- **importPrivateKey**: Necessary for importing an private key from a JWK format string.
- **encryptMessageForMultipleRecipients**: Necessary for encrypting a message with encryption for multiple recipients simultaneously.
- **decryptMessage**: Crucial for decrypting an encrypted message using the owner's private key.
- **encryptPrivateKey**: Required to encrypt an private key using AES-GCM encryption with a password.
- **decryptPrivateKey**: Needed to decrypt an encrypted private key using a password.
- **setupUserKeys**: Essential for setting up encryption keys for a user, ensuring each user has unique keys for secure communication and data exchange.
- **getUserKeys**: Crucial for retrieving encryption keys (public and private).
- **initializeKeys**: Vital for initializing encryption keys for a user, storing them securely in Firestore and locally (in localStorage).

The [Encryption file](/client/src/components/utils/Encryption.jsx) with detailed inline comments to explain everything further.

### 3. Auth Context

Next up is the `AuthContext.jsx` file. We will cover the creation and functionality of the `AuthContext` component. This component manages the authentication state, online status, and user keys within the application.

#### Import Dependencies

First, let's import the necessary dependencies:

```javascript
import React, {
  createContext,
  useState,
  useEffect,
  useCallback,
  useRef,
  useMemo,
} from "react";
import { getAuth, onAuthStateChanged, signOut } from "firebase/auth";
import { doc, setDoc, serverTimestamp, getFirestore } from "firebase/firestore";
import { getUserKeys, setupUserKeys } from "../chat/Encryption";
```

##### Methods and Callback Functions used in this component

1. **useState:** React hook used to manage state variables (`currentUser`, `userKeys`, `lastHeartbeat`), allowing components to re-render when state changes.
2. **useEffect:** React hook used to perform side effects in function components. It runs after every render and handles auth state changes (`onAuthStateChanged` listener) and setup of heartbeat and activity listeners.
3. **useCallback:** React hook used to memoize functions (`updateUserStatus`, `resetInactivityTimer`, `handleUserActivity`, `logout`). It ensures that functions are only recreated when their dependencies change, optimizing performance.
4. **useRef:** React hook used to keep mutable values (`inactivityTimerRef`, `lastStatusUpdateRef`) across renders without causing re-renders when they change.
5. **useMemo:** React hook used to memoize computed values (`isOnline`, `value`). It optimizes performance by caching the computed values and recalculating them only when necessary dependencies change.
6. **getAuth():** Function from Firebase Auth SDK to get the Auth instance.
7. **onAuthStateChanged:** Firebase Auth listener that triggers when the authentication state changes, updating `currentUser` state and fetching or setting up user keys accordingly.
8. **signOut:** Firebase Auth function to sign out the current user.
9. **doc, setDoc:** Firestore SDK functions for accessing and updating Firestore documents.
10. **serverTimestamp:** Firestore field value that represents the server timestamp when updating documents.
11. **getFirestore:** Function from Firestore SDK to get the Firestore instance.
12. **getUserKeys:** Function from `Encryption.jsx` (imported) to retrieve user encryption keys from Firestore or generate them if missing.
13. **setupUserKeys:** Function from `Encryption.jsx` (imported) to generate and store user encryption keys in Firestore.

#### Define Variables

We define several constants for managing user status and activity:

```javascript
const HEARTBEAT_INTERVAL = 45000;
const INACTIVITY_THRESHOLD = 180000;
const STATUS_UPDATE_THROTTLE = 10000;
```

- **HEARTBEAT_INTERVAL:** The interval (in milliseconds) at which the application sends "heartbeat" updates to indicate the user is still active.
- **INACTIVITY_THRESHOLD:** The time (in milliseconds) after which a user is considered inactive if no activity is detected.
- **STATUS_UPDATE_THROTTLE:** The minimum time (in milliseconds) between status updates to prevent excessive database writes.

#### Define Context and Provider

We create the authentication context and define the `AuthProvider` component:

```javascript
const AuthContext = createContext();

const AuthProvider = ({ children }) => {
  // ... (component implementation)
};
```

- **children:** Refers to the components nested within the provider component's JSX structure. This pattern enables passing down data or functions to multiple levels of nested components without having to explicitly pass props manually at each level.

#### Manage State

The `AuthProvider` component manages several state variables:

```javascript
const [currentUser, setCurrentUser] = useState(null);
const [userKeys, setUserKeys] = useState(null);
const [lastHeartbeat, setLastHeartbeat] = useState(null);
const inactivityTimerRef = useRef(null);
const lastStatusUpdateRef = useRef(0);
```

- **currentUser:** Stores the currently authenticated user.
- **userKeys:** Stores the user's encryption keys.
- **lastHeartbeat:** Tracks the timestamp of the last heartbeat.
- **inactivityTimerRef:** A ref to store the inactivity timer.
- **lastStatusUpdateRef:** A ref to store the timestamp of the last status update.

#### User Status Management

The component includes several functions for managing user status:

1. `updateUserStatus`: Updates the user's online status in Firestore.

```javascript
const updateUserStatus = useCallback(
  async (isOnline, bypassThrottle = false) => {
    if (currentUser) {
      const now = Date.now();
      if (
        bypassThrottle ||
        now - lastStatusUpdateRef.current > STATUS_UPDATE_THROTTLE
      ) {
        try {
          const db = getFirestore();
          const userRef = doc(db, "users", currentUser.uid);
          const userStatus = {
            online: isOnline,
            lastHeartbeat: serverTimestamp(),
          };
          await setDoc(userRef, userStatus, { merge: true });
          console.log("User status updated successfully.");
          setLastHeartbeat(now);
          lastStatusUpdateRef.current = now;
        } catch (error) {
          console.error("Error updating user status: ", error);
        }
      }
    }
  },
  [currentUser]
);
```

This function updates the user's online status and last heartbeat timestamp in Firestore. It includes a throttling mechanism to prevent excessive database writes.

2. `resetInactivityTimer`: Resets the inactivity timer.

```javascript
const resetInactivityTimer = useCallback(() => {
  if (inactivityTimerRef.current) {
    clearTimeout(inactivityTimerRef.current);
  }
  inactivityTimerRef.current = setTimeout(() => {
    updateUserStatus(false);
  }, INACTIVITY_THRESHOLD);
}, [updateUserStatus]);
```

This function clears any existing inactivity timer and sets a new one. If no activity is detected within the `INACTIVITY_THRESHOLD`, it updates the user's status to offline.

3. `handleUserActivity`: Handles user activity events.

```javascript
const handleUserActivity = useCallback(() => {
  if (currentUser) {
    updateUserStatus(true);
    resetInactivityTimer();
  }
}, [currentUser, updateUserStatus, resetInactivityTimer]);
```

This function is called when user activity is detected. It updates the user's status to online and resets the inactivity timer.

#### Logout Functionality

The component includes a `logout` function to handle user logout:

```javascript
const logout = useCallback(async () => {
  const auth = getAuth();
  try {
    await updateUserStatus(false, true);
    if (inactivityTimerRef.current) {
      clearTimeout(inactivityTimerRef.current);
    }
    await signOut(auth);
    setCurrentUser(null);
    setLastHeartbeat(null);
    setUserKeys(null);
  } catch (error) {
    console.error("Error during logout:", error);
  }
}, [updateUserStatus]);
```

This function updates the user's status to offline, clears the inactivity timer, signs out from Firebase, and resets the relevant state variables.

#### Effect Hooks

The component uses two main effect hooks:

1. Authentication state changes:

```javascript
useEffect(() => {
  const auth = getAuth();
  const unsubscribe = onAuthStateChanged(auth, async (user) => {
    if (user) {
      setCurrentUser(user);
      try {
        const keys = await getUserKeys(user.uid);
        setUserKeys(keys);
      } catch (error) {
        console.error("Error fetching user keys:", error);
        const newKeys = await setupUserKeys(user.uid);
        setUserKeys(newKeys);
      }
      await updateUserStatus(true);
    } else {
      if (currentUser) {
        await updateUserStatus(false);
      }
      setCurrentUser(null);
      setUserKeys(null);
      setLastHeartbeat(null);
    }
  });

  return () => unsubscribe();
}, [updateUserStatus]);
```

This effect listens for changes in the authentication state. When a user logs in, it sets the current user, fetches or sets up user keys, and updates the user's status to online. When a user logs out, it updates the status to offline and resets relevant state variables.

2. Heartbeat and activity listeners:

```javascript
useEffect(() => {
  let heartbeatInterval;

  if (currentUser) {
    heartbeatInterval = setInterval(() => {
      if (!document.hidden) {
        updateUserStatus(true);
      }
    }, HEARTBEAT_INTERVAL);

    window.addEventListener("keydown", handleUserActivity);
    resetInactivityTimer();
  }

  return () => {
    clearInterval(heartbeatInterval);
    window.removeEventListener("keydown", handleUserActivity);
    if (inactivityTimerRef.current) {
      clearTimeout(inactivityTimerRef.current);
    }
  };
}, [currentUser, handleUserActivity, resetInactivityTimer, updateUserStatus]);
```

This effect sets up a heartbeat interval and activity listeners when a user is logged in. It updates the user's status periodically and resets the inactivity timer on user activity.

#### Memoized Values

The component uses `useMemo` to optimize performance:

```javascript
const isOnline = useMemo(() => {
  return (
    !!currentUser &&
    lastHeartbeat &&
    Date.now() - lastHeartbeat < INACTIVITY_THRESHOLD
  );
}, [currentUser, lastHeartbeat]);

const value = useMemo(
  () => ({
    currentUser,
    userKeys,
    setUserKeys,
    lastHeartbeat,
    isOnline,
    logout,
  }),
  [currentUser, userKeys, lastHeartbeat, isOnline, logout]
);
```

These memoized values prevent unnecessary re-renders and provide an optimized way to check if a user is online.

#### Return Context Provider

Finally, let's return the `AuthContext.Provider` with the memoized value:

```javascript
return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
```

#### Complete AuthContext Component with Export

The complete `AuthContext` component is exported as follows:

```javascript
export { AuthProvider };
export default AuthContext;
```

The [AuthContext file](/client/src/components/context/AuthContext.jsx) with detailed inline comments to explain everything further.

### 4. Notification Context

Now let's cover the `NotificationContext.jsx` file. This component manages the notification state for unread messages across the application. It leverages Firebase Firestore to track unread messages in real-time.

#### Import Dependencies

First, let's examine the necessary imports:

```javascript
import React, { createContext, useState, useEffect, useContext } from "react";
import { collection, query, where, onSnapshot } from "firebase/firestore";
import { fireDB } from "../config/firebaseConfig";
import AuthContext from "./AuthContext.jsx";
```

- **React and Hooks:** We import `createContext`, `useState`, `useEffect`, and `useContext` from React. These hooks are essential for creating the context, managing state, handling side effects, and consuming other contexts.
- **Firestore Methods:** `collection`, `query`, `where`, and `onSnapshot` from "firebase/firestore" for querying and listening to real-time updates from Firestore.
- **fireDB:** Our custom Firebase Firestore database configuration.
- **AuthContext:** We import the AuthContext to access the current user's information.

#### Define Context and Provider

We create the notification context and define the `NotificationProvider` component:

```javascript
const NotificationContext = createContext();

const useNotification = () => useContext(NotificationContext);

const NotificationProvider = ({ children }) => {
  // ... (component implementation)
};
```

The `useNotification` hook provides an easy way for components to consume the NotificationContext.

#### Manage State

The `NotificationProvider` component manages the unread messages state and accesses the current user from AuthContext:

```javascript
const [unreadConversations, setUnreadConversations] = useState({});
const { currentUser } = useContext(AuthContext);
```

- **unreadConversations:** An object state that tracks the unread status for each conversation.
- **currentUser:** The currently authenticated user, obtained from AuthContext.

#### Real-time Unread Messages Tracking

The component uses an effect hook to track unread messages in real-time:

1. The effect runs when `currentUser` changes and only proceeds if there is a current user.

```javascript
useEffect(() => {
  if (!currentUser) return;

  // following part of component
}, []);
```

2. It creates a Firestore query to fetch all conversations where the current user is a participant.

```javascript
const { uid } = currentUser;

const conversationsQuery = query(
  collection(fireDB, "conversations"),
  where("participantIds", "array-contains", uid)
);
```

3. The `onSnapshot` listener is set up to react to real-time changes in these conversations.
4. For each conversation document, it checks if `!data.readStatus[uid]` is true for each conversation.
5. The `setUnreadConversations` function is called with the `unreadStatus` object, updating the state with the unread status of all conversations.

```javascript
const unsubscribe = onSnapshot(conversationsQuery, (snapshot) => {
  const unreadStatus = {};

  snapshot.docs.forEach((doc) => {
    const data = doc.data();
    unreadStatus[doc.id] = !data.readStatus[uid];
  });

  setUnreadConversations(unreadStatus);
});
```

6. The effect returns a cleanup function that unsubscribes from the Firestore listener when the component unmounts or when `currentUser` changes.

```javascript
useEffect(() => {
  // step 1 - 5
  return () => unsubscribe();
}, [currentUser]);
```

This setup ensures that the application always has up-to-date information about whether the current user has any unread messages across all their conversations.

#### Compute Overall Unread Status

The computation is added to determine if there are any unread messages across all conversations:

```javascript
const hasUnreadMessages = Object.values(unreadConversations).some(
  (status) => status
);
```

This `hasUnreadMessages` boolean will be true if any conversation has unread messages.

#### Return Context Provider

Finally, return the `NotificationContext.Provider` with the unread messages state:

```javascript
return (
  <NotificationContext.Provider
    value={{ unreadConversations, hasUnreadMessages }}
  >
    {children}
  </NotificationContext.Provider>
);
```

This makes both the `unreadConversations` object and the `hasUnreadMessages` boolean available to all child components that consume this context.

#### Complete NotificationContext Component with Export

The complete `NotificationContext` component is exported as follows:

```javascript
export { NotificationProvider, useNotification };
export default NotificationContext;
```

This allows other parts of the application to import and use the `NotificationProvider` component, the `useNotification` hook, and the `NotificationContext` itself.

The `NotificationContext` provides a centralized way to manage and access the unread messages status across the application. It tracks the unread status for each conversation separately, allowing for more granular control and display of notifications. The addition of the `useNotification` hook simplifies the consumption of this context in other components.

The [NotificationContext file](/client/src/components/context/NotificationContext.jsx) with detailed inline comments to explain everything further.

## Step 4. Build Landing Page and integrate components

First create the files inside the components directory:

```bash
touch NotFound.jsx HomePage.jsx
```

### 1. HomePage and Component Integration

Now that we have completed the Signup and Login components, let's integrate them into a central HomePage component. This component will serve as the main interface of our application, managing the user's session state and rendering different components based on authentication status.

#### NotFound

We mentioned the `"*"` route previously but didn't discuss the NotFound page or 404 error page. This is a good component to redirect authenticated users post-login. Eventually, users will be redirected to the messaging component, but for now, we'll create a placeholder component. This component can also serve as a fallback for mistyped URLs in your application.

You can just copy my code below, to keep it simple, it's just a static page with a heading and a button to return to the home page. Create a [NotFound.jsx file](/client/src/components/NotFound.jsx) in the components directory.

```javascript
import React from "react";
import { useNavigate } from "react-router-dom";

const NotFound = () => {
  const navigate = useNavigate();

  const handleGoHome = () => {
    navigate("/");
  };

  return (
    <div style={styles.container}>
      <h1 style={styles.title}>404 - Page Not Found</h1>
      <p style={styles.message}>
        Sorry, the page you are looking for does not exist.
      </p>
      <button style={styles.button} onClick={handleGoHome}>
        Go to Home
      </button>
    </div>
  );
};

export default NotFound;
```

#### HomePage Dependencies

First, we import all necessary dependencies:

```javascript
import React, { useContext, useState } from "react";
import AuthContext from "./context/AuthContext.jsx";
import { useNavigate } from "react-router-dom";
import LoginForm from "./Login.jsx";
import SignupForm from "./Signup.jsx";
import NotFound from "./NotFound.jsx";
```

Let's break down these imports:

- **React, useContext, and useState:** For building the component and managing state and context.
- **AuthContext:** Our custom context for managing authentication state.
- **useNavigate:** A hook from react-router-dom for programmatic navigation.
- **LoginForm, SignupForm and NotFound:** Our custom components.

#### HomePage Component

Let's define our HomePage component:

```javascript
const HomePage = () => {
  // Component code will go here
};
```

#### State Variables and Hooks

We'll use `useState` and `useContext` to manage our component's state:

```javascript
const { currentUser, logout } = useContext(AuthContext);
const [selectedTab, setSelectedTab] = useState("Login");
const navigate = useNavigate();
```

- **currentUser and logout:** We destructure these from our AuthContext. `currentUser` represents the authenticated user, and `logout` is a function to handle user logout.
- **[selectedTab, setSelectedTab]:** State to manage which tab (Login or Signup) is currently selected.
- **navigate:** We initialize the `useNavigate` hook for programmatic navigation.

#### Implement Logout Functionality

Let's create an asynchronous `handleLogout` function to manage the logout process:

1. Call the `logout` function from our AuthContext.
2. Remove the user token from local storage.
3. Reset the selected tab to "Login".
4. Navigate the user back to the homepage.
5. Log any errors that occur during the process.

```javascript
const handleLogout = async () => {
  try {
    await logout();
    localStorage.removeItem("userToken");
    setSelectedTab("Login");
    navigate("/");
  } catch (error) {
    console.error("Error signing out: ", error);
  }
};
```

#### Implement Tab Switch Functionality

We'll create a `handleTabClick` function to manage switching between Login and Signup tabs:

```javascript
const handleTabClick = (tab) => {
  setSelectedTab(tab);
};
```

This function updates the `selectedTab` state, which determines which component (LoginForm or SignupForm) to render.

#### Render UI

Now let's work on the `return` of this component. We'll structure it with three main sections: navigation, main content, and footer.

1. Start with a container div for the entire homepage:

```jsx
<div className="home-container">
  {/* Navigation, Main content, and Footer will go here */}
</div>
```

2. **Navigation:**
   - Displays the app logo and name.
   - Shows a logout button if a user is authenticated.

```jsx
<nav className="home-nav">
  <div className="logo">LOGO</div>
  <div className="name">CHAT APP</div>
  {currentUser && (
    <button className="logout" onClick={handleLogout}>
      Logout
    </button>
  )}
</nav>
```

3. **Main Content:**
   - If a user is authenticated (`currentUser` is truthy), it renders the `NotFound` component.
   - If no user is authenticated, it shows a landing page with login/signup options:
     - Two tabs for switching between Login and Signup forms.
     - Renders either `LoginForm` or `SignupForm` based on the `selectedTab` state.

```javascript
<main className="home-nav">
  {currentUser ? (
    <NotFound />
  ) : (
    <div className="landing-container">
      <div className="landing-box">
        <nav className="landing-nav">
          <ul>
            <li
              className={`login-tab ${selectedTab === "Login" ? "active" : ""}`}
              onClick={() => handleTabClick("Login")}
            >
              Login
            </li>
            <li
              className={`signup-tab ${
                selectedTab === "Signup" ? "active" : ""
              }`}
              onClick={() => handleTabClick("Signup")}
            >
              Signup
            </li>
          </ul>
        </nav>
        <main>
          {selectedTab === "Login" ? (
            <LoginForm />
          ) : (
            <SignupForm setSelectedTab={setSelectedTab} />
          )}
        </main>
      </div>
    </div>
  )}
</main>
```

4. **Footer:**
   - Displays credits or about information.

```jsx
<footer className="home-footer">
  <p className="footer-text">Credits or About information</p>
</footer>
```

#### Export Component

Finally, we export the HomePage component:

```javascript
export default HomePage;
```

This makes our HomePage component available for use in other parts of our application.

The HomePage component now serves as a central hub for our application, managing user authentication state and rendering the appropriate components based on that state. It integrates the Login and Signup components we created earlier and provides a seamless user experience for both authenticated and non-authenticated users.

The file [HomePage.jsx](/client/src/components/HomePage.jsx) has detailed inline comments to explain everything further.

### 2. Implementing Context Providers

Now that we have created both the `AuthContext` and `NotificationContext`, it's crucial to implement these context providers in our main `App.js` file. This ensures that the authentication state and notification status are available throughout our entire application.

Let's update our `App.js` file to include both context providers:

```javascript
// src/App.js

// imports ...
import React from "react";
import { Routes, Route } from "react-router-dom";

import { AuthProvider } from "./components/context/AuthContext.jsx";
import { NotificationProvider } from "./context/NotificationContext";
import HomePage from "./components/HomePage.jsx";
import NotFound from "./components/NotFound.jsx";

function App() {
  return (
    <AuthProvider>
      <NotificationProvider>
        <Router>
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route path="*" element={<NotFound />} />
          </Routes>
        </Router>
      </NotificationProvider>
    </AuthProvider>
  );
}

export default App;
```

Let's break down the changes and additions:

1. **Imports:**

   - We import both `AuthProvider` and `NotificationProvider` from their respective files.
   - We also import the necessary components for routing (`Router`, `Routes`, `Route`) and our page components (`HomePage`, `NotFound`).

2. **Context Provider Nesting:**

   - We wrap our entire application with the `AuthProvider`. This ensures that authentication state is available throughout the app.
   - Inside `AuthProvider`, we nest the `NotificationProvider`. This allows the notification context to access the authentication context if needed.

3. **Routing:**
   - We wrap our routes with the `Router` component from react-router-dom.
   - Inside the `Router`, we define our `Routes` with individual `Route` components for different paths.

By structuring our `App.js` file this way, we ensure that:

- Authentication state is available to all components, including the `NotificationProvider`.
- Notification state is available to all routed components.
- Our application is properly set up for routing.

This setup provides a solid foundation for building the rest of our application. Components can now easily access authentication and notification states using the `useContext` hook, and we have a clear routing structure in place.

### 3. First Test

Now let's head to our terminal and fire up `nodemon`. First, navigate to the `server` directory and type in `npm start`. You should get this response if everything went well:

```bash
Firebase Admin initialized
DB connected
The server is listening to port: 5000
```

Then, do the same inside the `client` directory: `npm start`, and you should get this response:

```bash
Compiled successfully!

You can now view the client in the browser.

  Local:            http://localhost:3000
  On Your Network:  http://YOUR.IP.IS.HERE:3000

Note that the development build is not optimized.
To create a production build, use npm run build.

webpack compiled successfully
```

At this point in the guide, you should be able to create an account using both email and password, as well as Google login. You should be able to view the created user on your Firebase Authentication Users Dashboard and find the corresponding user within your MongoDB project. If you encounter any problems or have other suggestions, please reach out to me, and I am happy to help or discuss improvements. However, you can mainly check the layout of the page and try switching between the different components.

## Step 5. Message Components

Now that we have everything else set up, let's dive straight into the messaging components. First, create the following files in the `client/src/components/chat/` directory:

```bash
touch ChatApp.jsx Messages.jsx Input.jsx UserList.jsx
```

These four chat components will be the focus of our development:

- **Chat App:** Combines all the chat components into a fully functional P2P Messaging App.
- **User List:** Displays all registered users and indicates users with whom we are currently communicating.
- **Messages:** This window displays all sent and received messages, along with related functionality such as message status.
- **Input:** This component handles user input and facilitates the sending functionality.

### 1. ChatApp Component

This component will serve as the core of our messaging application, integrating user lists, message displays, and input functionality.

#### Dependencies

First, import the necessary dependencies:

```javascript
import React, { useState, useContext, useRef, useEffect } from "react";
import AuthContext from "../context/AuthContext.jsx";
import ChatUserList from "./UserList.jsx";
import Message from "./Messages.jsx";
import SendMessage from "./Input.jsx";
```

- **React hooks:** We're using `useState`, `useContext`, `useRef`, and `useEffect` for state management and side effects.
- **AuthContext:** This will provide user authentication information.
- **Component imports:** We're importing the `ChatUserList`, `Message`, and `SendMessage` components that we'll create later.

#### Component Definition

Define the `MessageApp` component:

```javascript
const MessageApp = () => {
  // Component code here
};
```

#### State Variables

Set up state variables using the `useState` hook:

```javascript
const [selectedConversation, setSelectedConversation] = useState(null);
const [otherUserId, setOtherUserId] = useState(null);
const [otherUserName, setOtherUserName] = useState(null);
```

- **selectedConversation:** Stores the ID of the currently selected conversation.
- **otherUserId:** Stores the ID of the user you're chatting with.
- **otherUserName:** Stores the name of the user you're chatting with.

#### Context and Refs

Use the `useContext` hook to access the current user and their encryption keys:

```javascript
const { currentUser, userKeys } = useContext(AuthContext);
```

Create a ref for scrolling to the bottom of the message list:

```javascript
const scrollRef = useRef(null);
```

#### Helper Functions

Implement the `selectChat` function to handle conversation selection:

```javascript
const selectChat = (conversationId, otherUser, isNew = false) => {
  console.log("selectChat called with:", conversationId, otherUser, isNew);
  if (otherUser && otherUser.uid) {
    setSelectedConversation(conversationId);
    setOtherUserId(otherUser.uid);
    setOtherUserName(otherUser.displayName);
  } else {
    console.error("Invalid user selected:", otherUser);
    alert("Please select a valid user to start a conversation.");
  }
};
```

This function updates the state when a user selects a conversation or starts a new one.

#### Side Effects

Use the `useEffect` hook to scroll to the bottom of the message list when a conversation is selected:

```javascript
useEffect(() => {
  if (scrollRef.current) {
    scrollRef.current.scrollIntoView({ behavior: "smooth" });
  }
}, [selectedConversation]);
```

#### Render UI

Now, let's structure the return statement of our component:

```javascript
<div className="message-page">// message page components</div>
```

1. The left column (`user-chats-container`) displays the list of users and conversations.

```javascript
<div className="user-chats-container">
  <ChatUserList selectChat={selectChat} />
</div>
```

2. The right column (`message-area`) shows either the selected conversation (with messages and input field) or a prompt to select a conversation.

```javascript
<div className="message-area">
  {otherUserId ? (
    <>// Message and Input components</>
  ) : (
    <div className="no-conversation">
      Select a conversation or user to start messaging
    </div>
  )}
</div>
```

3. The chat interface is divided into two main parts: message display and message input. This separation of concerns makes the code more maintainable and easier to understand.

This first section inside the `message-area` is responsible for displaying the messages in the selected conversation.

```jsx
<div className="message-display">
  <Message
    conversationId={selectedConversation}
    scrollRef={scrollRef}
    privateKey={userKeys.privateKey}
    otherUserName={otherUserName}
  />
  <div ref={scrollRef}></div>
</div>
```

- `<div className="message-display">`: This is a container for the message display area.
- `<Message ... />`: This is a custom component that renders the actual messages. It receives several props:
  - `conversationId`: The ID of the currently selected conversation.
  - `scrollRef`: A reference to the scroll position, used to automatically scroll to the latest message.
  - `privateKey`: The user's private key.
  - `otherUserName`: The name of the user you're chatting with.
- `<div ref={scrollRef}></div>`: This empty div is used as a reference point for scrolling.

4. This section contains the input field for sending new messages.

```jsx
<div className="message-input">
  <SendMessage
    scroll={scrollRef}
    recipientId={otherUserId}
    conversationId={selectedConversation}
    publicKey={userKeys.publicKey}
    selectChat={selectChat}
  />
</div>
```

- `<div className="message-input">`: This is a container for the message input area.
- `<SendMessage ... />`: This is a custom component that renders the input field and send button. It receives several props:
  - `scroll`: The same scroll reference used in the Message component.
  - `recipientId`: The ID of the user you're sending the message to.
  - `conversationId`: The ID of the current conversation.
  - `publicKey`: The user's public key.
  - `selectChat`: A function to select or create a chat, used when starting a new conversation.

**Props:** Both the `Message` and `SendMessage` components receive various props. This allows these child components to access data and functions from the parent `ChatApp` component, enabling them to render correctly and interact with the application state.

**Scroll Functionality**: The `scrollRef` is used in both sections. In the message display, it's attached to an empty div at the end of the message list. In the input section, it's passed to the `SendMessage` component. This setup allows the chat to automatically scroll to the latest message when new messages are added or sent.

**Encryption**: The private key is used in the `Message` component for decryption, while the public key is used in the `SendMessage` component for encryption.

**Conditional Rendering**: This entire section is wrapped in a conditional statement that only renders these components when a conversation is selected. This prevents errors and provides a better user experience by not showing the chat interface when no conversation is active.

#### Export Component

Finally, export the `MessageApp` component:

```javascript
export default MessageApp;
```

The [file](/client/src/components/chat/ChatApp.jsx) with detailed inline comments.

### 2. Conversation and User List

The `ChatUserList` component manages the display of user conversations and all users available for chatting. It integrates with Firebase Firestore to dynamically fetch and update data based on user interactions.

#### Dependencies

First, import the necessary dependencies:

```javascript
import React, { useEffect, useState, useContext } from "react";
import {
  collection,
  query,
  where,
  orderBy,
  onSnapshot,
  addDoc,
  serverTimestamp,
  doc,
  updateDoc,
} from "firebase/firestore";
import { fireDB } from "../config/firebaseConfig.jsx";
import AuthContext from "../context/AuthContext.jsx";
import { useNotification } from "../context/NotificationContext.jsx";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faEnvelope } from "@fortawesome/free-solid-svg-icons";
```

- **React hooks:** We're using `useState`, `useContext`, and `useEffect` for state management and side effects.
- **Firebase Firestore:** We import various Firestore functions for querying and updating data.
- **AuthContext:** This provides user authentication information.
- **NotificationContext:** This manages unread conversation notifications.
- **FontAwesome:** We're using this for icons. Specifically, the `faEnvelope` icon from the free solid icon set. You need to install the following packages to use it:

```bash
npm install @fortawesome/fontawesome-svg-core @fortawesome/free-solid-svg-icons @fortawesome/react-fontawesome
```

#### OFFLINE_THRESHOLD

This constant is used to determine if a user is considered offline based on their last activity.

Define the variable for the offline threshold:

```javascript
const OFFLINE_THRESHOLD = 180000; // 3 minutes
```

#### Component Definition

Define the `ChatUserList` component:

```javascript
const ChatUserList = ({ selectChat }) => {
  // Component code here
};
```

The `selectChat` prop is a function that will be called when a chat or user is selected.

#### State Variables

Set up state variables using the `useState` hook:

```javascript
const [conversations, setConversations] = useState([]);
const [allUsers, setAllUsers] = useState([]);
const [selectedChatId, setSelectedChatId] = useState(null);
const [error, setError] = useState(null);
const [loading, setLoading] = useState(true);
```

- **conversations:** Stores the list of user conversations.
- **allUsers:** Stores the list of all users.
- **selectedChatId:** Tracks the ID of the currently selected chat.
- **error:** Stores any error messages.
- **loading:** Indicates whether data is being loaded.

#### Context

Use the `useContext` hook to access authentication and notification data:

```javascript
const { currentUser } = useContext(AuthContext);
const { unreadConversations } = useNotification();
```

#### Side Effects

Use the `useEffect` hook to fetch conversations and users:

```javascript
useEffect(() => {
  if (!currentUser) {
    setLoading(false);
    return;
  }

  const fetchAllUsers = () => {
    // Fetch all users logic
  };

  const fetchConversations = () => {
    // Fetch conversations logic
  };

  const unsubscribeUsers = fetchAllUsers();
  const unsubscribeConversations = fetchConversations();

  return () => {
    unsubscribeUsers();
    unsubscribeConversations();
  };
}, [currentUser]);
```

This effect runs when the component mounts or when `currentUser` changes. It fetches all users and conversations, and sets up real-time listeners for updates.

- **fetchAllUsers:** Retrieves all users from Firestore, excluding the current user. Here's a breakdown of its operation:

1. This line creates a query that targets the "users" collection in Firestore.

```javascript
const usersQuery = query(collection(fireDB, "users"));
```

2. This sets up a real-time listener on the query. It returns an unsubscribe function, which is later used to remove the listener when the component unmounts.

```javascript
return onSnapshot();
// step 3-6
```

3. Inside the `onSnapshot` callback:
   - Map over all documents in the snapshot. For each document, create an object that includes the document's ID and all its data fields.
   - Filter out the current user from the list, so users don't see themselves in the list of available chat partners.
4. Update the component's state with the new list of users.
5. Indicate that the data has finished loading.
6. Log any errors to the console and updates the component's error state.

```javascript
usersQuery,
  (snapshot) => {
    const userList = snapshot.docs
      .map((doc) => ({ id: doc.id, ...doc.data() }))
      .filter((user) => user.id !== currentUser.uid);
    setAllUsers(userList);
    setLoading(false);
  },
  (error) => {
    console.error("Error fetching users:", error);
    setError("Failed to load user list. Please try again later.");
    setLoading(false);
  };
```

- **fetchConversations:** This function sets up a real-time listener for the current user's conversations. Here's a detailed breakdown:

1. creates a complex query that:
   - Targets the "conversations" collection
   - Fetches conversations where the current user is a participant
   - Sorts conversations by their last update time, most recent first

```javascript
const conversationsQuery = query(
  collection(fireDB, "conversations"),
  where("participantIds", "array-contains", currentUser.uid),
  orderBy("lastUpdatedAt", "desc")
);
```

2. Set up a real-time listener and return an unsubscribe function.

```javascript
return onSnapshot(
  conversationsQuery,
  (snapshot) => {
    // step 3;
    // step 4;
    // step 4;
  },
  (error) => {
    // step 5
  }
);
```

3. Inside the `onSnapshot` callback:
   - Map over each conversation document.
   - For each document, it creates an object with:
     - The document's ID
     - All the document's data (spread with `...doc.data()`)
     - An `otherUser` field, which finds the participant that isn't the current user

```javascript
const conversationList = snapshot.docs.map((doc) => ({
  id: doc.id,
  ...doc.data(),
  otherUser: doc.data().participants.find((p) => p.uid !== currentUser.uid),
}));
```

4. Update the component's state with the new list of conversations and clear any previous errors, as the fetch goes successful.

```javascript
setConversations(conversationList);
setError(null);
```

5. Log any errors to the console and update the component's error state.

```javascript
console.error("Error fetching conversations:", error);
setError("Failed to load conversations. Please try again later.");
```

Both of these functions use Firestore's `onSnapshot` method, which sets up a listener that will automatically update the component's state whenever the relevant data in Firestore changes. This ensures that the user always sees the most up-to-date list of users and conversations without needing to manually refresh the page.

#### Helper Functions

Implement helper functions for user status and chat selection:

- **isUserOnline:** Determines if a user is online based on their last heartbeat timestamp.

1. If the user object doesn't exist or doesn't have a lastHeartbeat property, the function immediately returns false.
2. Handle different possible formats of the lastHeartbeat.
   - If lastHeartbeat is a Firestore Timestamp
   - If that Firestore lastHeartbeat fails, use the lastHeartbeat value as is.
3. The function should return true if all of these conditions are met:
   - The user's status is set to online
   - Heartbeat exists and is truthy
   - The time difference between now and the last heartbeat is less than OFFLINE_THRESHOLD

```javascript
const isUserOnline = (user) => {
  if (!user || !user.lastHeartbeat) return false;
  const lastHeartbeat =
    user.lastHeartbeat.toDate?.().getTime() || user.lastHeartbeat;
  return (
    user.online &&
    lastHeartbeat &&
    Date.now() - lastHeartbeat < OFFLINE_THRESHOLD
  );
};
```

- **handleSelectChat:** Handles the selection of an existing chat, updates the read status if necessary.

1. Update the component's state to reflect the newly selected chat.
2. Call the `selectChat` function and pass as a prop:
   - The ID of the selected chat
   - The other user's information
   - `false` to indicate this is not a new chat
3. Checks if there are unread messages in this conversation
4. If there are unread messages:
   - Create a reference to the conversation document in Firestore.
   - Update the document to mark the conversation as read for the current user.
   - Use a dynamic field name: `readStatus.${currentUser.uid}` to update the specific user's read status.

```javascript
const handleSelectChat = async (chat) => {
  setSelectedChatId(chat.id);
  selectChat(chat.id, chat.otherUser, false);

  if (unreadConversations[chat.id]) {
    const conversationRef = doc(fireDB, "conversations", chat.id);
    await updateDoc(conversationRef, {
      [`readStatus.${currentUser.uid}`]: true,
    });
  }
};
```

- **handleSelectUser:** Handles the selection of a user. If a conversation already exists with this user, it selects that chat. Otherwise, it creates a new conversation in Firestore.

1. It first checks if a conversation already exists with the selected user:

```javascript
const handleSelectUser = async (user) => {
  const existingConversation = conversations.find(
    (conv) => conv.otherUser.uid === user.id
  );
  if () {
  // step 2
  }  else {
    try {
  // step 3 - 6
    } catch (error) {
  // step 7
  }
  }
};
```

2. If an existing conversation is found, call `handleSelectChat` with that conversation.

```javascript
if (existingConversation) {
  handleSelectChat(existingConversation);
}
```

3. If no conversation is found, create a new one with:
   - Use `addDoc` to add a new document to the "conversations" collection in Firestore.
   - The new conversation document should include:
     - `participantIds`: An array of user IDs for quick querying
     - `participants`: An array of objects with more detailed user info
     - `lastUpdatedAt` and `createdAt`: Set to the current server timestamp
     - `readStatus`: Initially set to true for both participants

```javascript
const newConversationRef = await addDoc(collection(fireDB, "conversations"), {
  participantIds: [currentUser.uid, user.id],
  participants: [
    { uid: currentUser.uid, displayName: currentUser.displayName },
    { uid: user.id, displayName: user.displayName },
  ],
  lastUpdatedAt: serverTimestamp(),
  createdAt: serverTimestamp(),
  readStatus: { [currentUser.uid]: true, [user.id]: true },
});
```

4. After creating the Firestore document, create a local `newConversation` object with similar data. This is used to update the local state immediately without waiting for the next Firestore sync.

```javascript
const newConversation = {
  id: newConversationRef.id,
  otherUser: { uid: user.id, displayName: user.displayName },
  participantIds: [currentUser.uid, user.id],
  participants: [
    { uid: currentUser.uid, displayName: currentUser.displayName },
    { uid: user.id, displayName: user.displayName },
  ],
  lastUpdatedAt: new Date(),
  createdAt: new Date(),
  unread: false,
};
```

5. Update the local state with the new conversation:
   ```javascript
   setConversations([newConversation, ...conversations]);
   ```
6. Finally, call the `selectChat` function (passed as a prop) with the new conversation's details.

```javascript
selectChat(
  newConversationRef.id,
  { uid: user.id, displayName: user.displayName },
  true
);
```

7. If an error occurs during this process, log the error and updates the component's error state.

```javascript
console.error("Error creating new conversation:", error);
setError("Failed to create new conversation. Please try again.");
```

This function allows users to start new conversations seamlessly, creating the necessary data structures both in Firestore and in the local state.

#### Render UI

Structure the return statement of the component:

```javascript
return <div className="user-chats">{/* User chats components */}</div>;
```

1. The component is wrapped in a container with the class `user-chats`.

2. The component is divided into two main sections: Conversations and All Users.

First, let's look at the Conversations section:

```javascript
<div className="half-container">
  <h3>Your Conversations</h3>;
  <div className="list-container">
    {conversations.length > 0 ? (
      conversations.map((chat) => (
        <div
          key={chat.id}
          className={`chat-item ${
            chat.id === selectedChatId ? "selected" : ""
          } ${otherUser && isUserOnline(otherUser) ? "online" : "offline"}`}
          onClick={() => handleSelectChat(chat)}
        >
          {chat.otherUser?.displayName || "Unknown User"}
          {unreadConversations[chat.id] && (
            <FontAwesomeIcon icon={faEnvelope} className="unread-icon" />
          )}
        </div>
      ))
    ) : (
      <p>No conversations yet.</p>
    )}
  </div>
</div>
```

- A heading for the Conversations section.
- The section uses a ternary operator to either display a list of conversations or a message if there are no conversations.
- For each conversation, it renders a `div` with the following properties:
  - `key={chat.id}`: A unique key for React's reconciliation process.
  - `className`: A dynamic class name that indicates if the chat is selected and if the other user is online.
  - `onClick`: An event handler that calls `handleSelectChat` when the chat is clicked.
- The chat item displays the other user's name or "Unknown User" if the name is not available.
- If there are unread messages in the conversation, it displays an envelope icon.

Next, let's look at the All Users section:

```javascript
<div className="half-container">
  <h3>All Users</h3>;
  <div className="list-container">
    {sortedUsers.length > 0 ? (
      sortedUsers.map((user) => (
        <div
          key={user.id}
          className={`user-item ${isUserOnline(user) ? "online" : "offline"}`}
          onClick={() => handleSelectUser(user)}
        >
          {user.displayName || "Unknown User"}
        </div>
      ))
    ) : (
      <p>No other users found.</p>
    )}
  </div>
</div>
```

- A heading for the All Users section.
- Similar to the Conversations section, it uses a ternary operator to either display a list of users or a message if no users are found.
- For each user, it renders a `div` with the following properties:
  - `key={user.id}`: A unique key for React's reconciliation process.
  - `className`: A dynamic class name that indicates if the user is online.
  - `onClick`: An event handler that calls `handleSelectUser` when the user is clicked.
- The user item displays the user's name or "Unknown User" if the name is not available.

**Dynamic Rendering:** Both sections use conditional rendering to display appropriate content based on the available data. This ensures a good user experience whether there are many items to display or none.

**Online Status:** The component visually indicates the online status of users and conversation partners. This is determined by the `isUserOnline` function and reflected in the CSS classes.

**Interactivity:** Each item (conversation or user) is clickable, with appropriate click handlers to either select an existing conversation or start a new one.

**Unread Messages:** The component shows an icon for conversations with unread messages, providing a visual cue to the user.

**Sorted Users**: The All Users section uses a `sortedUsers` array, which sorts users based on online status criteria. This improves the usability of the user list.

#### Export Component

Finally, export the `ChatUserList` component:

```javascript
export default ChatUserList;
```

This `ChatUserList` component effectively manages and displays user conversations and available chat partners, integrating seamlessly with Firebase Firestore for real-time updates and interactions.

The [file](/client/src/components/chat/UserList.jsx) with detailed inline comments.

### 3. Messages Component

The `Message` component is responsible for displaying and managing messages within a conversation. It integrates with Firebase Firestore to fetch, decrypt, and update messages in real-time.

#### Dependencies

First, import the necessary dependencies:

```javascript
import React, { useEffect, useState, useContext } from "react";
import {
  collection,
  query,
  where,
  orderBy,
  onSnapshot,
  updateDoc,
  doc,
} from "firebase/firestore";
import { fireDB } from "../config/firebaseConfig";
import AuthContext from "../context/AuthContext";
import { decryptMessage } from "../utils/Encryption";
```

- **React hooks:** We're using `useState`, `useContext`, and `useEffect` for state management and side effects.
- **Firebase Firestore:** We import various Firestore functions for querying and updating data.
- **AuthContext:** This provides user authentication information and encryption keys.
- **decryptMessage:** A utility function for decrypting messages.

#### Component Definition

Define the `Message` component:

```javascript
const Message = ({ conversationId, scrollRef, otherUserName }) => {
  // Component code here
};
```

The component accepts three props:

- **conversationId:** The ID of the current conversation.
- **scrollRef:** A ref for scrolling to the latest message.
- **otherUserName:** The name of the user you're chatting with.

#### State Variables and Context

Set up state variables using the `useState` hook and the `useContext` hook to access authentication data and encryption keys:

```javascript
const [messages, setMessages] = useState([]);
const { currentUser, userKeys } = useContext(AuthContext);
```

- **messages:** Stores the list of messages in the current conversation.

#### Side Effects

The `useEffect` hook manages real-time updates for messages, handles decryption, updates message statuses, and ensures the chat view stays scrolled to the latest message.

```javascript
useEffect(() => {
  // Initial Check, step 1
  // Query Setup, step 2
  // Listener..., step 3 - 5
  return () => unsubscribe();
}, [conversationId, currentUser, userKeys, scrollRef]);
```

- Returns a cleanup function that unsubscribes from the Firestore listener when the component unmounts or the effect re-runs.

1. Initial Check:

```javascript
if (!conversationId || !currentUser || !userKeys) {
  setMessages([]);
  return;
}
```

- This checks if we have all necessary data to fetch messages.
- If any required data is missing, it resets the messages state and exits the effect.

2. Query Setup:

```javascript
const q = query(
  collection(fireDB, "messages"),
  where("conversationId", "==", conversationId),
  orderBy("timestamp", "asc")
);
```

- Targets the "messages" collection in Firestore
- Fetches messages for the current conversation
- Orders messages by timestamp in ascending order

3. Real-time Listener Setup:

```javascript
const unsubscribe = onSnapshot(q, async (snapshot) => {
  const messageList = await Promise.all(
    snapshot.docs.map(async (doc) => {
      const data = doc.data();
      let decryptedMessage = "";
      let decryptionError = null;
      try {
        decryptedMessage = await decryptMessage(
          userKeys.privateKey,
          data.message
        );
      } catch (error) {
        console.error("Error decrypting message for doc ID:", doc.id, error);
        decryptionError = error.message;
      }
      return {
        id: doc.id,
        ...data,
        decryptedMessage,
        decryptionError,
      };
    })
  );
  setMessages(messageList);
  // step 4 - 5
});
```

- Sets up a real-time listener on the query using `onSnapshot`.
- Returns an unsubscribe function, which can be used to remove the listener when needed.
- Uses `Promise.all` to handle the asynchronous decryption of all messages concurrently.
- Maps over each document in the snapshot:
  - Retrieves the document data.
  - Attempts to decrypt the message using the current user's private key.
  - Implements error handling for decryption:
    - If decryption fails, logs the error and stores the error message.
    - This ensures the application can gracefully handle decryption failures.
  - Creates an object with the document ID, all document data, the decrypted message (if successful), and any decryption error (if occurred).
- Updates the component's state with the new list of processed messages, including both successfully decrypted messages and those with decryption errors.

4. Message Status Update:

```javascript
messageList.forEach((message) => {
  if (message.senderId !== currentUser.uid) {
    updateDoc(doc(fireDB, "messages", message.id), {
      delivered: true,
      readBy: message.readBy.includes(currentUser.uid)
        ? message.readBy
        : [...message.readBy, currentUser.uid],
    });
  }
});
```

- Iterates through each message in the list.
- For messages not sent by the current user:
  - Marks the message as delivered.
  - Adds the current user to the `readBy` array if not already present.
- This updates the message status in Firestore.

5. If a scroll reference is provided and exists, it scrolls the view to the latest message smoothly.

```javascript
if (scrollRef && scrollRef.current) {
  scrollRef.current.scrollIntoView({ behavior: "smooth" });
}
```

#### Helper Functions

This function efficiently determines the status of a message based on its properties, allowing the UI to display appropriate status indicators for sent messages.

```javascript
const getMessageStatus = (message) => {
  if (message.senderId === currentUser.uid) {
    if (message.readBy.includes(message.recipientId)) return "Read";
    if (message.delivered) return "Delivered";
    return "Sent";
  }
  return "";
};
```

- This condition checks if the current user is the sender of the message.
  - Message status is only relevant for sent messages, not received ones.
- If the `readBy` array includes the recipient's ID, it means the message has been read.
  - In this case, the function immediately returns "Read".
- If the message hasn't been read but the `delivered` flag is true, it means the message has been delivered to the recipient's device.
  - In this case, the function returns "Delivered".
- If the message is neither read nor delivered, it means it has been sent but not yet received by the recipient.
  - The function returns "Sent" in this case.
- If the current user is not the sender (i.e., they received the message), the function returns an empty string.
  - This is because we typically don't display status for received messages.

#### Time Format

Just a quick function to make the time and date look prettier.

```javascript
const formatTimestamp = (timestamp) => {
  if (!timestamp) return "";
  const date = timestamp.toDate();
  const formattedDate = date.toLocaleDateString("en-GB").replace(/\//g, ".");
  const formattedTime = date.toLocaleTimeString("en-US", {
    hour: "2-digit",
    minute: "2-digit",
  });
  return `${formattedDate} ${formattedTime}`;
};
```

#### Conditional Rendering

The component uses conditional rendering to handle the case when there are no messages:

```javascript
if (messages.length === 0) {
  return (
    <div className="new-conversation-prompt">
      Start a conversation with {otherUserName}
    </div>
  );
}
```

- This condition checks if the `messages` array is empty.
- If there are no messages, the component renders a prompt instead of the message list.

#### Render UI

Structure the return statement of the component:

```javascript
if (messages.length === 0) {
  // Conditional Rendering
}

return (
  <div className="message-list">
    {messages.map((msg) => (
      <div
        key={msg.id}
        className={`message ${
          msg.senderId === currentUser.uid ? "sent" : "received"
        }`}
      >
        <div className="message-content">
          {msg.decryptionError ? (
            <span style={{ color: "red" }}>Error: {msg.decryptionError}</span>
          ) : (
            msg.decryptedMessage
          )}
        </div>
        <div className="message-timestamp">
          {formatTimestamp(msg.timestamp)}
        </div>
        <div className="message-status">{getMessageStatus(msg)}</div>
      </div>
    ))}
  </div>
);
```

- The component first checks if there are any messages.
- It uses the `map` function to iterate over the `messages` array and render each message:

  - Each message is wrapped in a `div` with a unique `key` prop set to the message's `id`.
  - The message `div` has a dynamic className to differentiate between sent and received messages.

- Inside each message `div`:

  1. Message Content:
     - If there's a `decryptionError`, it displays the error message in red.
     - Otherwise, it shows the `decryptedMessage`.
  2. Timestamp:
     - Displays the formatted timestamp using a `formatTimestamp` function.
  3. Message Status:
     - Shows the message status using a `getMessageStatus` function.

- The component handles potential decryption errors gracefully, displaying an error message instead of the decrypted content when necessary.
- The structure allows for easy styling of sent vs. received messages, as well as individual styling for the message content, timestamp, and status.

#### Export Component

Export the `Message` component

```javascript
export default Message;
```

The [file](/client/src/components/chat/Messages.jsx) with detailed inline comments.

### 4. Input Component

The `SendMessage` component is responsible for handling user input and sending messages within a conversation. It integrates with Firebase Firestore to create new conversations and send messages in real-time.

#### Dependencies

First, we import the necessary dependencies:

```javascript
import React, { useState, useContext, useEffect } from "react";
import { fireDB } from "../config/firebaseConfig.jsx";
import {
  addDoc,
  collection,
  doc,
  serverTimestamp,
  updateDoc,
  setDoc,
  getDoc,
} from "firebase/firestore";
import AuthContext from "../context/AuthContext.jsx";
import {
  encryptMessageForMultipleRecipients,
  importPublicKey,
} from "../utils/Encryption.jsx";
```

- **React hooks:** We're using `useState`, `useContext`, and `useEffect` for state management and side effects.
- **Firebase Firestore:** We import various Firestore functions for creating and updating documents.
- **AuthContext:** This provides user authentication information.
- **Encryption utilities:** Functions for encrypting messages and importing public keys.

#### Component Definition

We define the component and accept props:

```javascript
const SendMessage = ({ scroll, recipientId, conversationId, selectChat }) => {
  // Component code here
};
```

The component accepts four props:

- **scroll:** A ref for scrolling to the latest message.
- **recipientId:** The ID of the message recipient.
- **conversationId:** The ID of the current conversation (if it exists).
- **selectChat:** A function to select or create a chat.

#### State Variables

Set up state variables using the `useState` hook:

```javascript
const [message, setMessage] = useState("");
const [recipientDisplayName, setRecipientDisplayName] = useState("");
const [recipientPublicKey, setRecipientPublicKey] = useState(null);
```

- **message:** Stores the current message input.
- **recipientDisplayName:** Stores the display name of the recipient.
- **recipientPublicKey:** Stores the public key of the recipient for encryption.

#### Context

Use the `useContext` hook to access authentication data and user keys:

```javascript
const { currentUser, userKeys } = useContext(AuthContext);
```

#### Side Effects

Use the `useEffect` hook to fetch recipient information.

```javascript
useEffect(() => {
  const fetchRecipientInfo = async () => {
    // Function body
  };
  fetchRecipientInfo();
}, [recipientId]);
```

This effect runs when the `recipientId` changes, fetching the recipient's display name and public key from Firestore.

Let's break down the `fetchRecipientInfo` function:

1. Initial check to ensure we only proceed if a `recipientId` is provided.

```javascript
if (recipientId) {
  // Rest of the function
}
```

2. The entire fetching process is wrapped in a try-catch block. This allows for graceful error handling if any part of the process fails.

```javascript
try {
  // Fetching logic
} catch (error) {
  console.error("Error fetching recipient info:", error);
}
```

3. Create a document reference to the recipient's user document in Firestore and fetch actual document data from Firestore.

```javascript
const userDocRef = doc(fireDB, "users", recipientId);
const userDocSnapshot = await getDoc(userDocRef);
```

- Uses the `doc` function from Firestore, pointing to the "users" collection.
- Uses the `getDoc` function, which returns a promise resolving to a document snapshot.

4. Verify if the document actually exists in Firestore and if it doesn't exist, log an error message.

```javascript
if (userDocSnapshot.exists()) {
  const userData = userDocSnapshot.data();
  setRecipientDisplayName(userData.displayName);
  setRecipientPublicKey(await importPublicKey(userData.publicKey));
} else {
  console.error("Recipient user document not found");
}
```

- Extracts the actual data from the document snapshot.
- Updates the `recipientDisplayName` state with the fetched display name.
- Updates the `recipientPublicKey` state with the imported key.

This effect ensures that whenever the `recipientId` changes, the component fetches and sets up-to-date information about the recipient. This information is crucial for displaying the recipient's name and encrypting messages correctly.

#### Send Message Function

Implement the `sendMessage` function to handle message sending.

1. Check for a valid recipient, public key, and non-empty message.

```javascript
const sendMessage = async (event) => {
  event.preventDefault();

  if (!recipientId || !recipientPublicKey) {
    alert("Please select a valid recipient before sending a message.");
    return;
  }

  if (message.trim() === "") {
    alert("Please enter a message before sending.");
    return;
  }

  try {
    // try block, step 2 - 6
  } catch (error) {
    // Error handling step 6
  }
};
```

2. Encrypt the message for both the sender and recipient.

```javascript
const encryptedMessage = await encryptMessageForMultipleRecipients(message, [
  userKeys.publicKey,
  recipientPublicKey,
]);
```

3. Create a new conversation if needed, or use an existing one.

```javascript
let convId = conversationId;
if (!conversationId) {
  console.log("Creating new conversation");
  const newConversationRef = doc(collection(fireDB, "conversations"));
  await setDoc(newConversationRef, {
    documentId: newConversationRef.id,
    initiatedAt: serverTimestamp(),
    initiatedBy: currentUser.uid,
    lastMessage: {
      message: "Encrypted message",
      senderId: currentUser.uid,
      timestamp: serverTimestamp(),
    },
    lastUpdatedAt: serverTimestamp(),
    participants: [
      { uid: currentUser.uid, displayName: currentUser.displayName },
      { uid: recipientId, displayName: recipientDisplayName },
    ],
    participantIds: [currentUser.uid, recipientId],
    readStatus: { [currentUser.uid]: true, [recipientId]: false },
  });
  convId = newConversationRef.id;
  console.log("New conversation created with ID:", convId);

  selectChat(convId, {
    uid: recipientId,
    displayName: recipientDisplayName,
  });
}
```

4. Add the encrypted message to the Firestore 'messages' collection.

```javascript
const messagesCollectionRef = collection(fireDB, "messages");
await addDoc(messagesCollectionRef, {
  conversationId: convId,
  message: encryptedMessage,
  senderId: currentUser.uid,
  senderDisplayName: currentUser.displayName,
  recipientId,
  status: "sent",
  timestamp: serverTimestamp(),
  readBy: [currentUser.uid],
  delivered: false,
});
```

5. Update the conversation document with the latest message info.

```javascript
const conversationRef = doc(fireDB, "conversations", convId);
await updateDoc(conversationRef, {
  lastMessage: {
    message: "Encrypted message",
    senderId: currentUser.uid,
    timestamp: serverTimestamp(),
  },
  lastUpdatedAt: serverTimestamp(),
  [`readStatus.${recipientId}`]: false,
});
```

6. Clear the input field and scroll to the latest message. Finish by handling the errors that occur during the process.

```javascript
try {
  // step 2 - 5
  setMessage("");
  if (scroll && scroll.current) {
    scroll.current.scrollIntoView({ behavior: "smooth" });
  }
} catch (error) {
  console.error("Error sending message:", error);
  alert(
    "Failed to send message. Please try again or contact support if the issue persists."
  );
}
```

Each step involves interactions with Firestore, either creating new documents or updating existing ones. The function uses async/await syntax to handle these asynchronous operations and maintains proper error handling throughout.

#### Render UI

Structure the return statement of the component:

```javascript
return (
  <form onSubmit={sendMessage} className="send-message">
    <label htmlFor="messageInput" hidden>
      Enter Message
    </label>
    <input
      id="messageInput"
      name="messageInput"
      type="text"
      className="form-input__input"
      placeholder={`Message ${recipientDisplayName}`}
      value={message}
      onChange={(e) => setMessage(e.target.value)}
    />
    <button className="custom-button" type="submit">
      Send
    </button>
  </form>
);
```

This renders a form with an input field for the message and a submit button.

#### Export Component

Finally, export the `SendMessage` component:

```javascript
export default SendMessage;
```

This [SendMessage](/client/src/components/chat/Input.jsx) component efficiently handles message input and sending, integrating with Firebase Firestore and implementing message encryption for secure communication.

Now you can move on to the next part on [styling](styling.md).
